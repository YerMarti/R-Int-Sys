# =========================================================================
# This script has been created from a version generated by ChatGPT v3.5 and
# GitHub Copilot
# =========================================================================

# This function must return the problem structure
initialize.problem <- function(filename) {
  # Read the input file
  input <- readLines(filename)

  # Create the problem structure
  problem <- list()
  problem$name              <- paste0("Container Packing Problem - [", filename, "]")
  # Read input file to get product sizes and container size
  problem$product_sizes     <- c(as.numeric(unlist(strsplit(input[1], ";"))))
  problem$container_size    <- c(as.numeric(input[2]))
  # Initialize the state with each product in a separate container
  problem$state_initial     <- c(1:length(problem$product_sizes))
  # Initialize actions with one action for each product
  problem$actions_possible <- data.frame(action = sample(paste0("Update-", 1:length(problem$state_initial), sep = "")), stringsAsFactors = FALSE)

  return(problem)
}

# Analyzes if an action can be applied in the received state.
is.applicable <- function (state, action, problem) {
  # In this problem, any action is always applicable
  return(TRUE)
}

# Returns the state resulting on applying the action over the state
effect <- function (state, action, problem) {
  # Make a copy of the state
  result <- state

  # Extract the position from the action name
  position <- as.numeric(sub("Update-", "", action))

  # Retrieve product size for the product associated with the action
  product_size <- problem$product_sizes[position]

  # Randomly select a container
  container_index <- sample(state, 1)
  # Get the actual size of the container
  container_size <- sum(problem$product_sizes[state == container_index])

  # Update the container for the product if product fits in the container
  # randomly selected. If the product does not fit in the selected container,
  # the resulting state will be the same as the original.
  if ((container_size + product_size) <= problem$container_size) {
    result[position] <- container_index
  }

  return(result)
}

# Analyzes if a state is final or not
is.final.state <- function (state, final_state, problem) {
  # Always return TRUE as every state is considered final
  return(TRUE)
}

# Transforms a state into a string
to.string = function (state, problem) {
  # For simplicity, just return the state as a string
  return(paste(state, collapse = "-"))
}

# Returns the cost of applying an action over a state
get.cost <- function (action, state, problem) {
  # Cost is always 1 in this problem
  return(1)
}

# Heuristic function used by Informed Search Algorithms
get.evaluation <- function(state, problem) {
  # Return the number of different containers as the evaluation value
  return(length(unique(state)))
}
